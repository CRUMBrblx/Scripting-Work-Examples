local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")

local NetworkingCore = {}
NetworkingCore.__index = NetworkingCore

local NetworkFolder = ReplicatedStorage:WaitForChild("Network")
local RemotesFolder = NetworkFolder:WaitForChild("Remotes")

local ActionRemote = RemotesFolder:WaitForChild("Action")
local StateRemote = RemotesFolder:WaitForChild("State")
local AckRemote = RemotesFolder:WaitForChild("Ack")

local RATE_LIMIT_PER_SECOND = 15
local MAX_PAYLOAD_SIZE = 1024

local rateBuckets = {}
local lastActionId = {}
local subscriptions = {}
local pendingAcks = {}

local function now()
	return os.clock()
end

local function resetBucket(player)
	rateBuckets[player] = {
		count = 0,
		windowStart = now()
	}
end

local function canProcess(player)
	local bucket = rateBuckets[player]
	if not bucket then
		resetBucket(player)
		return true
	end

	local currentTime = now()
	if currentTime - bucket.windowStart >= 1 then
		resetBucket(player)
		return true
	end

	if bucket.count >= RATE_LIMIT_PER_SECOND then
		return false
	end

	bucket.count += 1
	return true
end

local function validPayload(payload)
	if typeof(payload) ~= "table" then
		return false
	end

	if typeof(payload.id) ~= "number" then
		return false
	end

	if typeof(payload.channel) ~= "string" then
		return false
	end

	if typeof(payload.data) ~= "table" then
		return false
	end

	local size = #game:GetService("HttpService"):JSONEncode(payload.data)
	if size > MAX_PAYLOAD_SIZE then
		return false
	end

	return true
end

local function hasReplay(player, id)
	local lastId = lastActionId[player]
	if not lastId then
		return false
	end
	return id <= lastId
end

local function updateLastId(player, id)
	lastActionId[player] = id
end

local function acknowledge(player, id)
	AckRemote:FireClient(player, id)
end

local function registerSubscription(player, channel)
	local playerSubs = subscriptions[player]
	if not playerSubs then
		playerSubs = {}
		subscriptions[player] = playerSubs
	end
	playerSubs[channel] = true
end

local function unregisterPlayer(player)
	rateBuckets[player] = nil
	lastActionId[player] = nil
	subscriptions[player] = nil
	pendingAcks[player] = nil
end

local function routeMessage(player, payload)
	local channel = payload.channel
	local playerSubs = subscriptions[player]
	if not playerSubs or not playerSubs[channel] then
		return
	end

	StateRemote:FireAllClients(channel, player, payload.data)
end

function NetworkingCore.init()
	ActionRemote.OnServerEvent:Connect(function(player, payload)
		if not canProcess(player) then
			return
		end

		if not validPayload(payload) then
			return
		end

		if hasReplay(player, payload.id) then
			return
		end

		updateLastId(player, payload.id)

		if payload.channel == "__subscribe" then
			if typeof(payload.data.channel) == "string" then
				registerSubscription(player, payload.data.channel)
				acknowledge(player, payload.id)
			end
			return
		end

		routeMessage(player, payload)
		acknowledge(player, payload.id)
	end)

	Players.PlayerRemoving:Connect(unregisterPlayer)

	RunService.Heartbeat:Connect(function()
		for player, bucket in pairs(rateBuckets) do
			if now() - bucket.windowStart >= 1 then
				resetBucket(player)
			end
		end
	end)
end

function NetworkingCore.broadcast(channel, data)
	for _, player in ipairs(Players:GetPlayers()) do
		local subs = subscriptions[player]
		if subs and subs[channel] then
			StateRemote:FireClient(player, channel, data)
		end
	end
end

function NetworkingCore.sendToPlayer(player, channel, data)
	local subs = subscriptions[player]
	if not subs then
		return
	end
	if not subs[channel] then
		return
	end
	StateRemote:FireClient(player, channel, data)
end

function NetworkingCore.hasSubscription(player, channel)
	local subs = subscriptions[player]
	if not subs then
		return false
	end
	return subs[channel] == true
end

function NetworkingCore.getRateUsage(player)
	local bucket = rateBuckets[player]
	if not bucket then
		return 0
	end
	return bucket.count
end

function NetworkingCore.forceDisconnect(player)
	unregisterPlayer(player)
	player:Kick("Network violation")
end

return NetworkingCore
